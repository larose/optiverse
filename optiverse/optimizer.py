import logging
from typing import cast

from .strategies import StrategyContext
from .prompt_generator import DefaultPromptGenerator, PromptGeneratorContext
from .store import FileSystemStore
from .config import OptimizerConfig
from .solution_generator import SolutionGenerator

logger = logging.getLogger(__name__)


class Optimizer:
    def __init__(self, config: OptimizerConfig):
        self._config = config

        self._store = FileSystemStore(directory=config.directory)
        self._prompt_generator = DefaultPromptGenerator()
        self._solution_generator = SolutionGenerator(llm_config=config.llm)

        self._evaluator = config.problem.evaluator
        self._strategy = config.search_strategy

    def _do_iteration(self, iteration: int):
        strategy_context = StrategyContext(
            iteration=iteration,
            store=self._store,
        )

        strategy_result = self._strategy.apply(context=strategy_context)

        prompt_generator_context = PromptGeneratorContext(
            strategy_result=strategy_result, problem=self._config.problem
        )

        prompt = self._prompt_generator.generate(prompt_generator_context)

        # Generate solution using the abstracted SolutionGenerator
        solution_response = self._solution_generator.generate(prompt)

        if not solution_response.code:
            logger.info("No code generated by solution generator")
            return

        file_content = solution_response.code
        description = solution_response.description

        logger.info("Evaluating solution")

        # Call evaluator on the temporary directory
        result = self._evaluator.evaluate(file_content)

        # Output the result of the evaluation
        if result.score is None:
            logger.info(
                "Evaluation failed - solution did not compile or produce valid results"
            )
        else:
            logger.info(f"Evaluation result: {result.score}")

        # Add parent solution information to tags
        enhanced_tags = strategy_result.tags.copy()
        for i, solution_with_title in enumerate(strategy_result.solutions, 1):
            enhanced_tags[f"parent_id_{i}"] = solution_with_title.solution.id
            enhanced_tags[f"parent_title_{i}"] = solution_with_title.title

        solution_id = self._store.add_solution(
            artifacts=result.artifacts,
            code=file_content,
            description=description,
            is_initial=False,
            metrics=result.metrics,
            prompt=prompt,
            score=result.score,
            tags=enhanced_tags,
        )
        self._strategy.result(iteration=iteration, score=result.score)

        if result.score is None:
            logger.info(f"Saved failed solution with ID: {solution_id} for debugging")
        else:
            logger.info(f"Saved solution with ID: {solution_id}")

    def run(self) -> None:
        logger.info("Evaluating and saving initial solution...")

        initial_solution_result = self._evaluator.evaluate(
            self._config.problem.initial_solution
        )

        # Save the initial solution
        initial_id = self._store.add_solution(
            artifacts=initial_solution_result.artifacts,
            code=self._config.problem.initial_solution,
            description=None,
            is_initial=True,
            metrics=initial_solution_result.metrics,
            prompt="",
            score=initial_solution_result.score,
            tags={},
        )

        logger.info(
            f"Initial solution saved with ID: {initial_id}, score: {initial_solution_result.score}"
        )

        for iteration in range(1, self._config.max_iterations + 1):
            try:
                logger.info(
                    f"Starting iteration {iteration}/{self._config.max_iterations}"
                )
                self._do_iteration(iteration=iteration - 1)
            except Exception as e:
                logger.info(
                    f"Iteration {iteration} failed with error: {e}", exc_info=True
                )
                continue

        # Show the best solution at the end
        logger.info("\n" + "=" * 50)
        logger.info("BEST SOLUTION:")
        logger.info("=" * 50)

        all_solutions = self._store.get_all_solutions()
        valid_solutions = [s for s in all_solutions if s.score is not None]

        if valid_solutions:
            # Sort by score (best first) and get the top solution
            sorted_solutions = sorted(
                valid_solutions, key=lambda x: cast(float, x.score)
            )
            best_solution = sorted_solutions[0]
            logger.info(f"ID: {best_solution.id}")
            logger.info(f"Score: {best_solution.score}")

            if best_solution.description:
                logger.info("\nExplanation:")
                logger.info("-" * 30)
                logger.info(f"\n{best_solution.description}")
                logger.info("-" * 30)

            logger.info("\nSource code:")
            logger.info("-" * 30)
            logger.info(f"\n{best_solution.code}")
            logger.info("-" * 30)
        else:
            logger.info("No valid solutions found - all solutions failed evaluation")
